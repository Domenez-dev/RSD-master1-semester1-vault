<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>devoir algo</title>
  <link rel="stylesheet" href="https://stackedit.io/style.css" />
  <style>
    @page {
        size: A4;
        margin: 10mm;
    }

    body {
        width: 100%;
        max-width: 100%;
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }
    body {
      font-family: Arial, sans-serif;
      background-color: #f9f9f9;
      color: #333;
      margin: 20px;
      max-width: 1000px;
      margin-left: auto;
      margin-right: auto;
    }
    h1, h3, h4 {
      color: #0056b3;
    }
    hr {
      border: 1px solid #0056b3;
    }
    pre, code {
      background-color: #e9ecef;
      border: 1px solid #ced4da;
      border-radius: 4px;
      padding: 2px;
      font-size: 0.9em;
    }
    ul {
      list-style-type: disc;
      margin-left: 20px;
    }
    li {
      margin-bottom: 10px;
    }
    .highlight-fonction {
      color: #0056b3; /* Cool red color from Catppuccin theme */
      font-weight: bold;
    }
    .highlight-retourner {
      color: #800080; /* Purple color */
      font-weight: bold;
    }
    .highlight-complexity {
      color: #d9534f; /* Red color */
      font-weight: bold;
    }
    .highlight-variable {
      color: #1e90ff; /* Dark green color */
      font-weight: bold;
    }
    .highlight-loop {
      color: #006400; /* Dodger Blue color */
      font-weight: bold;
    }
    .highlight-condition {
      color: #ff8c00; /* Dark Orange color */
      font-weight: bold;
    }
    .highlight-comment {
      color: #696969; /* Dim Gray color */
      font-style: italic;
    }
  </style>
</head>

<body class="stackedit">
  <div class="stackedit__html">
    <h1 id="devoir-maison-algo-et-complexity">Devoir maison Algo et complexity</h1>
    <p>etudiant: Bouzara Zakaria<br>
    matricule: 212138069681</p>
    <hr>
    <h3 id="algorithme-iteraif-pour-calculer-le-produit-de-deux-matrices">1. Algorithme iteraif pour calculer le produit de deux matrices:</h3>
    <pre><code><span class="highlight-fonction">fonction</span> produit_matrices_carres(<span class="highlight-variable">E</span>: A, B [n][n]entier, <span class="highlight-variable">S</span>: [n][n]entier){
    <span class="highlight-loop">pour</span> i=0 ; i&lt;n ; i++ <span class="highlight-loop">faire</span>:
        <span class="highlight-loop">pour</span> j=0 ; j&lt;n ; j++ <span class="highlight-loop">faire</span>:
            <span class="highlight-loop">pour</span> k=0 ; k&lt;n ; k++ <span class="highlight-loop">faire</span>:
                C[i][j] += A[i][k] * B[k][i];
            <span class="highlight-loop">fait</span>;
        <span class="highlight-loop">fait</span>;
    <span class="highlight-loop">fait</span>;
    <span class="highlight-retourner">retourner</span> C
<span class="highlight-fonction">fin</span>
</code></pre>
    <ul>
      <li>
        <p><strong>La complexity de cette algorithme:</strong><br>
        On a 3 boucles <code>pour</code> chacune itère de 0 à n (n est la taille de la matrice carrée A), alors <span class="highlight-complexity">O(n^3)</span>.</p>
      </li>
      <li>
        <p>Pour cet algorithme de multiplication de matrices, la complexité temporelle <span class="highlight-complexity">O(n^3)</span> est obtenue dans tous les cas (pire, meilleur et cas moyen). car l’algorithme est fixe et dépend uniquement de la taille des matrices.</p>
      </li>
    </ul>
    <h3 id="modifiant-lalgorithme-pour-diffrent-tailles-des-matrices">2. Modifiant l’algorithme pour diffrent tailles des matrices:</h3>
    <pre><code><span class="highlight-fonction">fonction</span> produit_matrices_non_carres(<span class="highlight-variable">E</span>: A [m][n]entier, B [n][p]entier <span class="highlight-variable">S</span>: [m][p]entier){
    <span class="highlight-loop">pour</span> i=0 ; i&lt;m ; i++ <span class="highlight-loop">faire</span>:                    <span class="highlight-comment">//m &lt;- nbr de lignes de A</span>
        <span class="highlight-loop">pour</span> j=0 ; j&lt;p ; j++ <span class="highlight-loop">faire</span>:                <span class="highlight-comment">//p &lt;- nbr de colomns de B</span>
            <span class="highlight-loop">pour</span> k=0 ; k&lt;n ; k++ <span class="highlight-loop">faire</span>:        <span class="highlight-comment">//n &lt;- nbr de lignes de B</span>
                C[i][j] += A[i][k] * B[k][i];
            <span class="highlight-loop">fait</span>;
        <span class="highlight-loop">fait</span>;
    <span class="highlight-loop">fait</span>;
    <span class="highlight-retourner">retourner</span> C
<span class="highlight-fonction">fin</span>
</code></pre>
    <ul>
      <li><strong>La complexity de cette algorithme:</strong><br>
      on a 3 boucle <code>pour</code> qui itère de 0 a differents valeur m, p et m alors <span class="highlight-complexity">O(n.m.p)</span></li>
    </ul>
    <h3 id="algorithme--recursive-pour-calculer-le-produit">Algorithme  recursive pour calculer le produit</h3>
    <pre><code><span class="highlight-fonction">fonction</span> produit_recursive(<span class="highlight-variable">E</span>: A [m][n]entier, B [n][p]entier <span class="highlight-variable">S</span>: [m][p], i, j, k entier){
    <span class="highlight-condition">si</span> i &gt;= m:
        <span class="highlight-retourner">retourner</span> C <span class="highlight-comment">//condition d'arret, en retourne C comme resultat</span>
    <span class="highlight-condition">fsi</span>;
    <span class="highlight-condition">si</span> j &gt;= p:
        <span class="highlight-retourner">retourner</span> produit_recursive(A, B, C, i+1, j, 0) <span class="highlight-comment">//passer au prochaine colomn</span>
    <span class="highlight-condition">fsi</span>;
    <span class="highlight-condition">si</span> k &gt;= n:
        <span class="highlight-retourner">retourner</span> produit_recursive(A, B, C, i, j+1, 0) <span class="highlight-comment">//passer au prochaine ligne</span>
    <span class="highlight-condition">fsi</span>;
    
    C[i][j] = A[i][k] * B[k][j]
    <span class="highlight-retourner">retourner</span> produit_recursive(A, B, C, i, j, k+1)
<span class="highlight-fonction">fin</span>
</code></pre>
    <ul>
      <li><strong>La complexity de cette algorithme:</strong></li>
    </ul>
    <p>La fonction <code>produit_recursive</code> itère de <code>0</code> à <code>m</code> (condition d’arrêt), incrémentant <code>i</code>. À chaque fois, elle s’appelle avec une incrémentation de <code>j</code>, qui est responsable d’itérer sur les colonnes de <code>B</code>. Dans chaque appel, cette dernière appelle elle-même en incrémentant <code>k</code> jusqu’à <code>k = n</code>.</p>
    <p>Pour chaque élément du résultat, la fonction effectue une série de multiplications et d’additions. Étant donné les trois niveaux de récursion, la complexité temporelle totale de cette fonction est <span class="highlight-complexity">O(m × n × p)</span>.</p>
    <h3 id="la-multiplications-des-matrices-utilisant-la-decomposition">la Multiplications des matrices utilisant la decomposition</h3>
    <h4 id="étape-1--diviser-les-matrices">Étape 1 : Diviser les Matrices</h4>
    <p>Tout d’abord, nous divisons chaque matrice en quatre sous-matrices de (<span class="highlight-complexity">n/2 × n/2</span>). Par exemple, si nous avons la matrice ( A ), elle est divisée en :</p>
    <pre><code>A11 = [1  2]   A12 = [3  4]
      [5  6]         [7  8]

A21 = [9  10]  A22 = [11 12]
      [13 14]        [15 16]
</code></pre>
    <h4 id="étape-2--multiplication-récursive">Étape 2 : Multiplication Récursive</h4>
    <p>Ensuite, nous multiplions récursivement les sous-matrices pour calculer les nouvelles sous-matrices du résultat. Nous calculons :</p>
    <pre><code>C11 = A11 * B11 + A12 * B21
C12 = A11 * B12 + A12 * B22
C21 = A21 * B11 + A22 * B21
C22 = A21 * B12 + A22 * B22
</code></pre>
    <h4 id="étape-3--fusionner-les-sous-matrices">Étape 3 : Fusionner les Sous-matrices</h4>
    <p>Enfin, nous fusionnons les sous-matrices (C11), (C12), (C21), et (C22) pour former la matrice résultat finale.</p>
    <h4 id="lalgorithme-correspondant">l’algorithme correspondant:</h4>
    <pre><code>// Étape 1 : Diviser les Matrices
<span class="highlight-fonction">fonction</span>  decompositionMatrice(<span class="highlight-variable">E</span>: A [n][n]entier
<span class="highlight-variable">S</span>: [n/2][n/2]eniter, [n/2][n/2]eniter, [n/2][n/2]eniter, [n/2][n/2]eniter)  
    A11  = A[:mid][:mid]
    A12  = A[mid:][:mid]
    A21  = A[:mid][mid:]
    A22  = A[mid:][mid:]
    <span class="highlight-retourner">retourner</span>  A11, A12, A21, A22,
<span class="highlight-fonction">fin</span>
</code></pre>
    <pre><code>// Étape 2 : Multiplication Récursive
<span class="highlight-fonction">fonction</span>  multiplication(A, B [n][n]entier) ([n][n]entier)
    <span class="highlight-condition">Si</span> n = 1 <span class="highlight-condition">Alors</span>
        <span class="highlight-retourner">retourner</span> [[A[0][0] * B[0][0]]]
    <span class="highlight-condition">Sinon</span>
        A11, A12, A21, A22  = decompositionMatrice(A)
        B11, B12, B21, B22  = decompositionMatrice(B)
        C11  =  ajoutDeuxMatrices(multiplication(A11, B11), multiplication(A12, B21))
        C12  =  ajoutDeuxMatrices(multiplication(A11, B12), multiplication(A12, B22))
        C21  =  ajoutDeuxMatrices(multiplication(A21, B11), multiplication(A22, B21))
        C22  =  ajoutDeuxMatrices(multiplication(A21, B12), multiplication(A22, B22))
        <span class="highlight-retourner">retourner</span>  fusionMatrices(C11, C12, C21, C22)
    <span class="highlight-condition">FinSi</span>
<span class="highlight-fonction">fin</span>
</code></pre>
    <pre><code>// Étape 3 : Fusionner les Sous-matrices

<span class="highlight-fonction">fonction</span>  ajoutDeuxMatrices(A, B [n][n]entier) ([n][n]entier)
    n = longueur(A)
    <span class="highlight-retourner">retourner</span> [[A[i][j] + B[i][j] pour j de 0 à n-1] pour i de 0 à n-1]
<span class="highlight-fonction">fin</span>

<span class="highlight-fonction">fonction</span>  fusionMatrices(C11, C12, C21, C22 [n][n]entier) ([n*2][n*2]entier)
    <span class="highlight-retourner">retourner</span> [C11[i] +  C12[i] pour i de 0 à n-1] + [C21[i] +  C22[i] pour i de 0 à n-1]
<span class="highlight-fonction">fin</span>
</code></pre>
    <h3 id="complexité-de-lalgorithme">Complexité de l’algorithme</h3>
    <ol>
      <li>
        <p><strong>Division des matrices (SplitMatrix)</strong> :<br>
        Diviser une matrice (n * n) en quatre sous-matrices prend (O(1)) temps, car il s’agit simplement de réorganiser les pointeurs ou les indices.</p>
      </li>
      <li>
        <p><strong>Multiplication récursive (RecursiveMatrixMult)</strong> :<br>
        Pour multiplier les sous-matrices, nous effectuons 8 multiplications récursives de matrices de taille (<span class="highlight-complexity">n/2 × n/2</span>). Chaque multiplication récursive a une complexité <span class="highlight-complexity">T(n/2)</span>.</p>
      </li>
      <li>
        <p><strong>Addition de matrices (AddMatrices)</strong> :<br>
        L’addition de deux matrices de taille (n * n) a une complexité de <span class="highlight-complexity">O(n^2)</span>.</p>
      </li>
    </ol>
    <h3 id="formule-de-récursion">Formule de récursion</h3>
    <p>L’algorithme suit la relation de récurrence suivante pour la multiplication de matrices :</p>
    <p><span class="highlight-complexity">T(n) = 8.T(n/2) + O(n^2)</span></p>
  </div>
</body>
</html>